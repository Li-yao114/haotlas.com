---
title: DES加密算法
date: 2024-03-23 12:29:22
lang: zh
summary: des加密算法
---
## 一、算法简介

### 1、对称加密：

是一种加密方式，使用相同的密钥进行加密和解密过程。在对称加密中，发送方使用密钥将明文转换为密文，而接收方使用相同的密钥将密文解密为原始明文。对称加密的优点是速度快，适合大量数据加密，但缺点是密钥的安全性，因为发送方和接收方必须共享密钥。

### 2、Feistel密码结构：

是对称加密算法中常用的一种结构。它将明文分成两部分，通过一系列轮函数和密钥的迭代应用，对每个部分进行加密或解密。每个轮函数都接受一半数据和子密钥，然后产生一个输出。输出与另一半数据进行XOR运算，然后两部分数据进行交换。这个过程被重复多次（通常是16次），直到最后一个轮函数，最后再进行一次交换，最终得到密文。

Feistel密码结构的设计使得加密和解密的过程可以共享相同的代码，只需反向使用子密钥即可。这种结构的优点是实现简单，安全性高，易于分析和理解。DES（数据加密标准）就是基于Feistel密码结构的一种加密算法，它采用了这种结构进行加密和解密过程。

### 3、流密码与分组密码：

- 流密码：是一种逐位加密的方式，它将明文分成若干个字符或位，然后逐个进行加密。 这种加密方式使用一个密钥流和一个初始化向量，将明文中的每个字符与密钥流中的字符进行逐位异或操作，从而生成密文。

- 块密码（即分组密码）：是将明文消息编码表示后的数字序列，划分成长度相等的组，暂且定义为n，n>0，每组分别在密钥的控制下变换成等长的数组数字序列。

### 4、DES算法：

- DES算法是属于对称密码算法中的分组加密算法。

- 密钥长64位，56位参与运算，其余8位为校验位（8，16，24，32，40，48，56，64）

- 当n个64位明文数据块都经过DES加密处理后，得到的n个64位密文数据块串在一起就是密文。

## 二、加密流程

### 1、密钥生成过程：

密钥为64位，除去8位校验位，剩余56位参与运算。按照交换规则，生成16个48位的轮密钥。

1.密钥转换表：

[![](https://haotlas.cn/wp-content/uploads/2024/03/f7a1310415b0854c55c54f4a145451be.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/f7a1310415b0854c55c54f4a145451be.jpg)

2.每一轮子密钥循环左移次数：

[![](https://haotlas.cn/wp-content/uploads/2024/03/ec07d53ca58f48fb84c1543f76bf8f7f.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/ec07d53ca58f48fb84c1543f76bf8f7f.jpg)

3.DES子密钥的置换选择：

[![](https://haotlas.cn/wp-content/uploads/2024/03/d15f8d303e6b5c04abb2d43cab9a5cb9.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/d15f8d303e6b5c04abb2d43cab9a5cb9.jpg)

计算子密钥的过程：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323100944.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323100944.png)

### 2、加密和解密数据块：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323093358.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323093358.png)

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323104724.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323104724.png)

#### ①初始IP置换：

按照一定规则，将原来的64位二进制位重新排序

[![](https://haotlas.cn/wp-content/uploads/2024/03/ffc9c8965f77ef9f86edd801e9ff8d78.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/ffc9c8965f77ef9f86edd801e9ff8d78.jpg)

如上如图，即将原来的第58位的数据放到第1位......

#### ②轮函数：

a.E扩展置换：将32位输入扩展为48位输出（为了和48位的密钥进行运算）

[![](https://haotlas.cn/wp-content/uploads/2024/03/e6f16472213725431a850729580a1a3b.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/e6f16472213725431a850729580a1a3b.jpg)

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323105916.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323105916.png)

有多种扩展置换方法，无非是把分成的组两侧增加第一位和最后一位，第一位是上一组增加前的最后一位，最后一位是下一组增加前的第一位。

b.S盒压缩处理：经过扩展后的48位明文和48位密钥进行异或运算后，再使用8个S盒压缩处理得到32位数据。将48位输入等分为8块，每块6位输入压缩为4位输出。

例：原始数据：111111

头尾数据：11转化为十进制3，即为行数

中间数据：1111转化为十进制15，即为列数

然后在盒中找到对应数值（0-3，0-15）。

[![](https://haotlas.cn/wp-content/uploads/2024/03/ed2ff11ebb5ff3a1cec6d74ea56a3dbd.jpg)](https://haotlas.cn/wp-content/uploads/2024/03/ed2ff11ebb5ff3a1cec6d74ea56a3dbd.jpg)

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323102104.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240323102104.png)

c.P盒置换：S盒所得结果再经过P盒置换。至此一次轮函数操作完毕。

[![](https://haotlas.cn/wp-content/uploads/2024/03/626c6774bc918c3005d9f7e09f00e912.png)](https://haotlas.cn/wp-content/uploads/2024/03/626c6774bc918c3005d9f7e09f00e912.png)

#### ③最终置换：

[![](https://haotlas.cn/wp-content/uploads/2024/03/9c81b3d55cee76d600cf1394c36b4ff3.png)](https://haotlas.cn/wp-content/uploads/2024/03/9c81b3d55cee76d600cf1394c36b4ff3.png)

## 三、代码

DES.cpp代码如下：

#include
#include
#include
#include
using namespace std;
​
int fill_cnt = 0;
bitset sub_key[16];
​
//密钥转换表
const int my_zh[56] = {57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18,
                      10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36,
                      63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22,
                      14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4};
​
//每一轮子密钥循环左移次数
const int RTL[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
​
//DES子密钥的置换选择
const int zh_xz[48] = {14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10,
                      23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2,
                      41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
                      44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32};
​
//初始IP置换
const int IP[64] = {58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4,
                   62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8,
                   57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3,
                   61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7};
​
//最终置换
const int RIP[64] = {40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55,23, 63, 31,
                    38, 6, 46, 14, 54, 22, 62, 30, 37, 5,45, 13, 53, 21, 61, 29,
                    36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27,
                    34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25};
​
//轮函数
//E扩展置换
const int E[] = {32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
                8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1};
​
//S盒压缩处理
const int S[8][4][16] = {
  {{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
    {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
    {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
    {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}},
  {{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
    {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
    {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
    {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},
  {{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
    {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
    {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
    {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},
  {{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
    {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
    {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
    {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},
  {{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
    {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
    {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
    {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},
  {{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
    {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
    {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
    {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},
  {{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
    {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
    {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
    {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},
  {{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
    {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
    {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
    {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}};
​
//P盒置换
const int P[32] = {16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10,
                  2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25};
​
​
   bitset str2bit(string str) {
       bitset bit;
       int k = 0;
       for (int i = 0; i > (7 - j)) & 1;
          }
      }
       return bit;
  }
​
   //将字符串转换为bitset对象
   string bit2str(bitset bit) {
       string str = "";
       for (int i = 0; i  rotate_left(bitset bit, int step) {
       bitset rotated_bit;
       for (int i = 0; i  key_bit = str2bit(key);
       bitset PC_1_key_bit;
       for (int i = 0; i  C;
       bitset D;
       for (int i = 0; i  F(bitset R, bitset sub_key) {
       bitset E_R;
       for (int i = 0; i  S_R;
       for (int i = 0, j = 0; i  S_out_bit(S_out);
           S_R[j] = S_out_bit[3];
           S_R[j + 1] = S_out_bit[2];
           S_R[j + 2] = S_out_bit[1];
           S_R[j + 3] = S_out_bit[0];
      }
       bitset P_R;
       for (int i = 0; i  bit_encrypt(bitset plain_bit) {
       bitset IP_bit;
       for (int i = 0; i  L;
       bitset R;
       for (int i = 0; i  L_tmp;
       for (int i = 0; i  merge_bit;
       for (int i = 0; i  encrypt_bit;
       for (int i = 0; i  bit_decrypt(bitset encrypt_bit) {
       bitset IP_bit;
       for (int i = 0; i  L;
       bitset R;
       for (int i = 0; i  L_tmp;
       for (int i = 15; i >= 0; i--) {
           L_tmp = L;
           L = R;
           R = L_tmp ^ F(R, sub_key[i]);
      }
       bitset merge_bit;
       for (int i = 0; i  decrypt_bit;
       for (int i = 0; i  plain_bit = str2bit(plain_txt);
           bitset encrypt_bit = bit_encrypt(plain_bit);
           string encrypt_txt = bit2str(encrypt_bit);
           fout  encrypt_bit = str2bit(encrypt_txt);
           bitset decrypt_bit = bit_decrypt(encrypt_bit);
           string decrypt_txt = bit2str(decrypt_bit);
           if (i == block_cnt - 1) {
               while (fill_cnt) {
                   decrypt_txt.erase(decrypt_txt.size() - 1);
                   fill_cnt -= 8;
              }
          }
           fout << decrypt_txt;
           encrypt_txt.erase(0, 8);
      }
       fin.close();
       fout.close();
  }
​
int main() {
   ofstream encrypt_file("encrypt.txt", ios::trunc);
   encrypt_file.close();
   ofstream decrypt_file("decrypt.txt", ios::trunc);
   decrypt_file.close();
​
   string key = "ucalzped";
   encrypt("plain.txt", "encrypt.txt", key);
   decode("encrypt.txt", "decrypt.txt", key);
​
   return 0;
}

——代码来自郑钦烽

创建plain.txt文件，写入需要加密的内容，例如：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110305.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110305.png)

运行加密算法文件，得到的加密后的文件encrypt.txt：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110310.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110310.png)

还有得到解密后的文件decrypt.txt：

[![](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110312.png)](https://haotlas.cn/wp-content/uploads/2024/03/QQ图片20240326110312.png)

以上为物联网安全小组实验内容，梳理一遍逻辑结构，便于本人后续遗忘的情况下可以快速翻阅回忆。

——结尾于2024年3月26日上午11：16分。

参考链接：

[DES加密算法｜密码学｜信息安全_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KQ4y127AT/?spm_id_from=333.337.search-card.all.click&vd_source=c348ac61ef5d4b98ec0f23fd71057b5a)

[DES加密算法原理与实现_des数据加密、解密算法-CSDN博客](https://blog.csdn.net/bemodesty/article/details/114999946)